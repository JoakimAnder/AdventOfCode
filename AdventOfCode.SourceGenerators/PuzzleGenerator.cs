using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
#nullable enable

namespace AdventOfCode.SourceGenerators;

[Generator]
public class PuzzleGenerator : IIncrementalGenerator
{
    private const string NameSpace = "AdventOfCode";
    private const string AttributeName = "Puzzle";
    private const string AttributeClassName = $"{AttributeName}Attribute";
    private const string AttributeFullName = $"{NameSpace}.{AttributeClassName}";
    private const string PartialModifier = "partial";

    private const string InterfaceName = "IPuzzle";
    private const string InterfaceFullName = $"{NameSpace}.{InterfaceName}";
    private const string YearMemberName = "Year";
    private const string DayMemberName = "Day";
    private const string NameMemberName = "Name";
    private const string OneStarSolutionCodeMemberName = "OneStarSolutionCode";
    private const string TwoStarSolutionCodeMemberName = "TwoStarSolutionCode";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(GenerateAttribute);
        context.RegisterPostInitializationOutput(GenerateInterface);
        var pipeline = context.SyntaxProvider.ForAttributeWithMetadataName(AttributeFullName, CheckIfNodeIsValid, TransformNode);
        context.RegisterSourceOutput(pipeline, GenerateSourceText);

        context.RegisterSourceOutput(pipeline.Collect(), GenerateDependencyInjectionExtentionClass);
    }

    private static void GenerateAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        const string code = $$"""
            // <auto-generated/>
            using System;
            namespace {{NameSpace}};

            [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
            public sealed class {{AttributeClassName}}(int year, int day, string name, Type oneStarSolutionType, Type twoStarSolutionType) : Attribute
            {
                public int Year { get; } = year;
                public int Day { get; } = day;
                public string Name { get; } = name;
                public Type OneStarSolutionType { get; } = oneStarSolutionType;
                public Type TwoStarSolutionType { get; } = twoStarSolutionType;
            }
            """;
        context.AddSource($"{AttributeClassName}.g.cs", code);
    }

    private static void GenerateInterface(IncrementalGeneratorPostInitializationContext context)
    {
        const string code = $$"""
            // <auto-generated/>
            using System;
            namespace {{NameSpace}};

            public interface {{InterfaceName}}
            {
                int {{YearMemberName}} { get; }
                int {{DayMemberName}} { get; }
                string {{NameMemberName}} { get; }
                string {{OneStarSolutionCodeMemberName}} { get; }
                string {{TwoStarSolutionCodeMemberName}} { get; }
            }
            """;
        context.AddSource($"{InterfaceName}.g.cs", code);
    }

    private static bool CheckIfNodeIsValid(SyntaxNode node, CancellationToken token)
    {
        if (node is not ClassDeclarationSyntax m)
        {
            return false;
        }
        if (!m.Modifiers.Any(mod => mod.ValueText == PartialModifier))
        {
            return false;
        }
        if (m.BaseList?.Types.Any(t => t.Type.ToString() == InterfaceName) != true)
        {
            return false;
        }

        return true;
    }

    private static PuzzleInfo TransformNode(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (context.TargetNode is not ClassDeclarationSyntax c)
            throw new ArgumentException(nameof(context.TargetNode));
        if (c.Parent is not BaseNamespaceDeclarationSyntax ns)
            throw new ArgumentException(nameof(c.Parent));

        var nameSpace = ns.Name.ToString();
        var className = context.TargetSymbol.Name.ToString();


        var classModifiers = c.Modifiers.ToString();
        var classBases = c.BaseList?.ToString();

        var attribute = context.Attributes.First(a => a.AttributeClass?.Name == AttributeClassName);
        var year = c.Members.Any(m => m.ToString() == YearMemberName) ? null : attribute.ConstructorArguments[0].Value as int?;
        var day = c.Members.Any(m => m.ToString() == DayMemberName) ? null : attribute.ConstructorArguments[1].Value as int?;
        var name = c.Members.Any(m => m.ToString() == NameMemberName) ? null : attribute.ConstructorArguments[2].Value as string;
        var oneStarClass = c.Members.Any(m => m.ToString() == OneStarSolutionCodeMemberName) ? null : attribute.ConstructorArguments[3].Value as INamedTypeSymbol;
        var twoStarClass = c.Members.Any(m => m.ToString() == TwoStarSolutionCodeMemberName) ? null : attribute.ConstructorArguments[4].Value as INamedTypeSymbol;

        var oneStarClassFullName = oneStarClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
        var twoStarClassFullName = twoStarClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));

        static string? GetCode(ITypeSymbol? symbol)
        {
            var targetClassNode = symbol?.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;
            var targetClassCode = targetClassNode?.GetText().ToString();
            return targetClassCode;
        }
        var oneStarCode = GetCode(oneStarClass);
        var twoStarCode = GetCode(twoStarClass);

        return new PuzzleInfo(nameSpace, className, classModifiers, year, day, name, oneStarCode, twoStarCode, oneStarClassFullName, twoStarClassFullName);
    }

    private static void GenerateSourceText(SourceProductionContext context, PuzzleInfo source)
    {
        static string GenerateStrPropCode(string propName, string? value)
        {
            if (value is null)
                return string.Empty;

            var regex = new Regex("(\"+)");
            var quoteCount = 2;
            if (value == string.Empty)
                quoteCount = 0;
            else
            {
                foreach (var m in regex.Matches(value))
                {
                    if (m is not Match match || match.Value.Length <= quoteCount)
                        continue;
                    quoteCount = match.Value.Length;
                }
            }
            var quotes = string.Join("", Enumerable.Range(0, quoteCount + 1).Select(_ => "\""));
            return $$"""public string {{propName}} { get; } = {{quotes}}{{value}}{{quotes}};""";
        }

        var fileName = $"{source.NameSpace}.{source.ClassName}_{InterfaceName}.g.cs";

        var sourceText = SourceText.From($$$"""
            // <auto-genarated/>
            using {{{NameSpace}}};

            namespace {{{source.NameSpace}}};
            {{{source.ClassModifiers}}} class {{{source.ClassName}}} : {{{InterfaceName}}}
            {
                {{{(source.Year is null ? string.Empty : $$"""public int {{YearMemberName}} { get; } = {{source.Year}};""")}}}
                {{{(source.Day is null ? string.Empty : $$"""public int {{DayMemberName}} { get; } = {{source.Day}};""")}}}
                {{{GenerateStrPropCode(NameMemberName, source.Name)}}}
                {{{GenerateStrPropCode(OneStarSolutionCodeMemberName, source.OneStarSolutionCode)}}}
                {{{GenerateStrPropCode(TwoStarSolutionCodeMemberName, source.TwoStarSolutionCode)}}}
            }
            """, System.Text.Encoding.UTF8);

        context.AddSource(fileName, sourceText);
    }


    private static void GenerateDependencyInjectionExtentionClass(SourceProductionContext context, ImmutableArray<PuzzleInfo> s)
    {
        var registrations = s.SelectMany(puzzle =>
        {
            var result = new List<string>();
            if (puzzle.Year is null || puzzle.Day is null)
                return result;

            var puzzleRegistration = $"""services.AddKeyedSingleton<global::{InterfaceFullName}, global::{puzzle.NameSpace}.{puzzle.ClassName}>("{puzzle.Year}.{puzzle.Day}");""";
            result.Add(puzzleRegistration);

            if (puzzle.OneStarSolutionClassFullName is not null)
            {
                var registration = $"""services.AddKeyedScoped<ISolution, global::{puzzle.OneStarSolutionClassFullName}>("{puzzle.Year}.{puzzle.Day}.1");""";
                result.Add(registration);
            }

            if (puzzle.TwoStarSolutionClassFullName is not null)
            {
                var registration = $"""services.AddKeyedScoped<ISolution, global::{puzzle.TwoStarSolutionClassFullName}>("{puzzle.Year}.{puzzle.Day}.2");""";
                result.Add(registration);
            }

            return result;
        });

        var sourceText = SourceText.From($$"""
            // <auto-genarated/>
            using Microsoft.Extensions.DependencyInjection;
            using AdventOfCode.Shared.Solutions;

            namespace {{NameSpace}};

            public static class Generated_Puzzle_ServiceCollectionExtentions
            {
                public static IServiceCollection AddPuzzlesAndSolutions(this IServiceCollection services)
                {
                    {{string.Join("\n", registrations)}}

                    return services;
                }
            }
            """, System.Text.Encoding.UTF8);
        context.AddSource("DependencyInjection_Puzzles.g.cs", sourceText);
    }

    private class PuzzleInfo(
        string nameSpace,
        string className,
        string classModifiers,
        int? year,
        int? day,
        string? name,
        string? oneStarSolutionCode,
        string? twoStarSolutionCode,
        string? oneStarSolutionClassFullName,
        string? twoStarSolutionClassFullName
        )
    {
        public string NameSpace { get; } = nameSpace;
        public string ClassName { get; } = className;
        public string ClassModifiers { get; } = classModifiers;
        public int? Year { get; } = year;
        public int? Day { get; } = day;
        public string? Name { get; } = name;
        public string? OneStarSolutionCode { get; } = oneStarSolutionCode;
        public string? TwoStarSolutionCode { get; } = twoStarSolutionCode;
        public string? OneStarSolutionClassFullName { get; } = oneStarSolutionClassFullName;
        public string? TwoStarSolutionClassFullName { get; } = twoStarSolutionClassFullName;
    }
}
